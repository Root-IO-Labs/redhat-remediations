/**
 * CVE-2026-22184 Vulnerability Demonstration
 * 
 * This C program demonstrates the buffer overflow vulnerability in zlib's untgz utility.
 * 
 * VULNERABILITY:
 *   - TGZfname() function copies archive name into fixed 1024-byte buffer
 *   - Uses unbounded strcpy() without length check
 *   - Archive names > 1024 bytes cause buffer overflow
 * 
 * VULNERABLE CODE (from zlib contrib/untgz/untgz.c):
 *   char fname[1024];
 *   char *TGZfname(const char *name) {
 *       strcpy(fname, name);  // VULNERABLE!
 *       ...
 *   }
 * 
 * USAGE:
 *   gcc -fno-stack-protector -o vulnerable_demo vulnerable_untgz_demo.c
 *   ./vulnerable_demo
 *   ./vulnerable_demo 2000  # Trigger overflow with 2000-byte name
 * 
 * WARNING: This demonstrates a real vulnerability. The program will crash
 *          with a segmentation fault when given filenames > ~1500 bytes.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* The vulnerable buffer size from zlib untgz */
#define VULNERABLE_BUFFER_SIZE 1024

/* Simulated vulnerable code from zlib untgz */
char fname[VULNERABLE_BUFFER_SIZE];  /* Fixed-size global buffer */
char canary[32] = "CANARY_INTACT!!!";  /* Canary to detect overflow */

/**
 * Simulated TGZfname - the vulnerable function
 * This is a simplified version of the actual vulnerable function in zlib
 */
char *vulnerable_TGZfname(const char *name) {
    /* THIS IS THE VULNERABILITY: strcpy without bounds check */
    strcpy(fname, name);  /* Will overflow if name > 1024 bytes! */
    return fname;
}

/**
 * Safe version using strncpy - how it should be implemented
 */
char *safe_TGZfname(const char *name) {
    strncpy(fname, name, VULNERABLE_BUFFER_SIZE - 1);
    fname[VULNERABLE_BUFFER_SIZE - 1] = '\0';
    return fname;
}

void print_header(void) {
    printf("╔═══════════════════════════════════════════════════════════════════════════════╗\n");
    printf("║           CVE-2026-22184 Buffer Overflow Demonstration                        ║\n");
    printf("║                    zlib untgz vulnerability                                   ║\n");
    printf("╚═══════════════════════════════════════════════════════════════════════════════╝\n\n");
}

void test_vulnerable_function(int name_length) {
    printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    printf("TEST: Filename length = %d bytes\n", name_length);
    printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    
    int overflow = name_length - VULNERABLE_BUFFER_SIZE;
    printf("  Buffer size:    %d bytes\n", VULNERABLE_BUFFER_SIZE);
    printf("  Input length:   %d bytes\n", name_length);
    printf("  Overflow:       %d bytes\n", overflow > 0 ? overflow : 0);
    printf("  Expected:       %s\n", overflow > 0 ? "OVERFLOW (CRASH/CORRUPTION)" : "OK");
    printf("\n");
    
    /* Reset canary */
    strcpy(canary, "CANARY_INTACT!!!");
    
    /* Create test input */
    char *test_input = malloc(name_length + 1);
    if (!test_input) {
        printf("  ERROR: Memory allocation failed\n");
        return;
    }
    memset(test_input, 'A', name_length);
    test_input[name_length] = '\0';
    
    printf("  Canary before:  \"%s\"\n", canary);
    printf("  Calling vulnerable_TGZfname()...\n");
    
    /* Call the vulnerable function - this may crash! */
    vulnerable_TGZfname(test_input);
    
    printf("  Canary after:   \"%s\"\n", canary);
    
    /* Check if overflow occurred */
    if (strcmp(canary, "CANARY_INTACT!!!") != 0) {
        printf("\n  ⚠️  BUFFER OVERFLOW DETECTED!\n");
        printf("  The canary was overwritten, indicating memory corruption.\n");
        printf("  In real untgz, this could allow code execution.\n");
        printf("  RESULT: VULNERABLE ❌\n");
    } else if (overflow > 0) {
        printf("\n  Note: Canary not overwritten (depends on memory layout)\n");
        printf("  But strcpy DID write past buffer bounds!\n");
        printf("  RESULT: POTENTIALLY VULNERABLE ⚠️\n");
    } else {
        printf("\n  ✅ No overflow (input within buffer size)\n");
        printf("  RESULT: OK ✅\n");
    }
    
    free(test_input);
    printf("\n");
}

void test_safe_function(int name_length) {
    printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    printf("SAFE TEST: Filename length = %d bytes with bounds checking\n", name_length);
    printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    
    /* Reset canary */
    strcpy(canary, "CANARY_INTACT!!!");
    
    /* Create test input */
    char *test_input = malloc(name_length + 1);
    if (!test_input) {
        printf("  ERROR: Memory allocation failed\n");
        return;
    }
    memset(test_input, 'B', name_length);
    test_input[name_length] = '\0';
    
    printf("  Canary before:  \"%s\"\n", canary);
    printf("  Calling safe_TGZfname() with strncpy...\n");
    
    /* Call the safe function */
    safe_TGZfname(test_input);
    
    printf("  Canary after:   \"%s\"\n", canary);
    printf("  Copied length:  %zu bytes (truncated if > %d)\n", 
           strlen(fname), VULNERABLE_BUFFER_SIZE - 1);
    
    if (strcmp(canary, "CANARY_INTACT!!!") == 0) {
        printf("\n  ✅ No overflow with safe function\n");
        printf("  RESULT: SAFE ✅\n");
    } else {
        printf("\n  ❌ Unexpected overflow!\n");
        printf("  RESULT: ERROR ❌\n");
    }
    
    free(test_input);
    printf("\n");
}

int main(int argc, char *argv[]) {
    print_header();
    
    printf("VULNERABILITY DETAILS:\n");
    printf("  CVE ID:       CVE-2026-22184\n");
    printf("  Component:    zlib untgz utility (contrib/untgz/untgz.c)\n");
    printf("  Issue:        Global buffer overflow in TGZfname()\n");
    printf("  Root cause:   strcpy() without bounds checking\n");
    printf("  Buffer size:  %d bytes\n", VULNERABLE_BUFFER_SIZE);
    printf("  Trigger:      Archive filename > %d bytes\n", VULNERABLE_BUFFER_SIZE);
    printf("\n");
    
    printf("VULNERABLE CODE:\n");
    printf("  char fname[1024];\n");
    printf("  char *TGZfname(const char *name) {\n");
    printf("      strcpy(fname, name);  // ← VULNERABLE: no bounds check!\n");
    printf("      ...\n");
    printf("  }\n\n");
    
    /* Get test size from argument or use defaults */
    if (argc > 1) {
        int size = atoi(argv[1]);
        if (size > 0) {
            printf("Testing with custom size: %d bytes\n\n", size);
            test_vulnerable_function(size);
            test_safe_function(size);
            return 0;
        }
    }
    
    /* Default tests */
    int test_sizes[] = {512, 1024, 1025, 2000, 4096};
    int num_tests = sizeof(test_sizes) / sizeof(test_sizes[0]);
    
    printf("Running vulnerability tests with default sizes...\n\n");
    
    for (int i = 0; i < num_tests; i++) {
        test_vulnerable_function(test_sizes[i]);
    }
    
    printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    printf("                              COMPARISON\n");
    printf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    printf("\n");
    printf("  VULNERABLE (untgz):  Uses strcpy() → Buffer overflow possible\n");
    printf("  SAFE (Java):         Uses dynamic allocation → No overflow\n");
    printf("\n");
    printf("  Java's java.util.zip does NOT use fixed-size C buffers,\n");
    printf("  so it cannot be affected by this vulnerability.\n");
    printf("\n");
    
    /* Show safe function for comparison */
    test_safe_function(2000);
    
    return 0;
}
