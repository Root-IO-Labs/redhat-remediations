import java.io.*;
import java.nio.file.*;
import java.util.zip.*;

/**
 * CVE-2026-22184 Simple Buffer Overflow Test
 * 
 * Tests whether Java's compression APIs are vulnerable to the
 * buffer overflow that affects zlib's untgz utility.
 */
public class TestBufferOverflow {
    
    private static final int VULNERABLE_BUFFER = 1024;
    
    public static void main(String[] args) {
        System.out.println("╔═══════════════════════════════════════════════════════════════════════════════╗");
        System.out.println("║         CVE-2026-22184 Buffer Overflow Test - Java Compression APIs           ║");
        System.out.println("╚═══════════════════════════════════════════════════════════════════════════════╝");
        System.out.println();
        
        System.out.println("VULNERABILITY: zlib untgz buffer overflow");
        System.out.println("  - Fixed 1024-byte buffer for archive filenames");
        System.out.println("  - strcpy() without bounds check causes overflow");
        System.out.println("  - Filenames > 1024 bytes trigger memory corruption");
        System.out.println();
        
        int[] testSizes = {1024, 1025, 2048, 4096, 8192};
        int passed = 0;
        int total = 0;
        
        for (int size : testSizes) {
            total++;
            if (testZipWithLongFilename(size)) {
                passed++;
            }
        }
        
        System.out.println();
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("                              SUMMARY");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("  Tests passed: " + passed + "/" + total);
        System.out.println();
        
        if (passed == total) {
            System.out.println("  ✅ JAVA IS NOT VULNERABLE TO CVE-2026-22184");
            System.out.println();
            System.out.println("  Java's java.util.zip handles long filenames safely because:");
            System.out.println("  • Uses dynamic memory allocation (not fixed buffers)");
            System.out.println("  • No unsafe C-style string operations");
            System.out.println("  • Bounds checking on all operations");
            System.exit(0);
        } else {
            System.out.println("  ❌ UNEXPECTED FAILURES - Review output above");
            System.exit(1);
        }
    }
    
    private static boolean testZipWithLongFilename(int filenameLength) {
        int overflow = filenameLength - VULNERABLE_BUFFER;
        
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("TEST: " + filenameLength + "-byte filename" + 
                          (overflow > 0 ? " (would overflow by " + overflow + " bytes in untgz)" : " (at buffer limit)"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        
        try {
            String longFilename = "X".repeat(filenameLength - 4) + ".txt";
            String content = "Test content for " + filenameLength + " byte filename test";
            
            System.out.println("  Creating ZIP with " + longFilename.length() + "-byte filename...");
            
            Path zipFile = Files.createTempFile("cve-test-", ".zip");
            
            try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
                ZipEntry entry = new ZipEntry(longFilename);
                zos.putNextEntry(entry);
                zos.write(content.getBytes());
                zos.closeEntry();
            }
            
            System.out.println("  ZIP created: " + Files.size(zipFile) + " bytes");
            System.out.println("  Extracting and verifying...");
            
            try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {
                ZipEntry entry = zis.getNextEntry();
                if (entry != null) {
                    String readName = entry.getName();
                    byte[] readContent = zis.readAllBytes();
                    String readStr = new String(readContent);
                    
                    boolean nameMatch = readName.equals(longFilename);
                    boolean contentMatch = readStr.equals(content);
                    
                    System.out.println("  Filename match:  " + (nameMatch ? "✅" : "❌"));
                    System.out.println("  Content match:   " + (contentMatch ? "✅" : "❌"));
                    
                    Files.deleteIfExists(zipFile);
                    
                    if (nameMatch && contentMatch) {
                        System.out.println("  RESULT: PASS ✅ (No buffer overflow - handled safely)");
                        System.out.println();
                        return true;
                    }
                }
            }
            
            Files.deleteIfExists(zipFile);
            System.out.println("  RESULT: FAIL ❌");
            System.out.println();
            return false;
            
        } catch (Exception e) {
            System.out.println("  Exception: " + e.getMessage());
            System.out.println("  RESULT: ERROR ❌");
            System.out.println();
            return false;
        }
    }
}
