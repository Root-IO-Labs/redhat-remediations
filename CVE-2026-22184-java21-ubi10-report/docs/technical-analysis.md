# CVE-2026-22184 Technical Analysis

## Vulnerability Deep Dive

### The Vulnerable Code

Location: `zlib/contrib/untgz/untgz.c`

```c
/* Global buffer - 1024 bytes fixed size */
char fname[1024];

/* Vulnerable function */
char *TGZfname(const char *name) {
    char *p = strrchr(name, '/');
    
    /* VULNERABILITY: unbounded strcpy into fixed buffer */
    strcpy(fname, name);  /* No length check! */
    
    if (p != NULL) {
        /* ... process filename ... */
    }
    return fname;
}
```

### Attack Scenario

1. Attacker creates/provides a tar.gz archive with a filename > 1024 bytes
2. Victim runs `untgz malicious.tar.gz`
3. `TGZfname()` is called with the long filename
4. `strcpy()` copies beyond the 1024-byte buffer boundary
5. Memory corruption occurs
6. Potential outcomes:
   - Crash (denial of service)
   - Code execution (if attacker controls overwritten memory)

### Memory Layout

```
Lower addresses
┌─────────────────────────────────────┐
│         fname[1024]                 │  ← Target buffer
├─────────────────────────────────────┤
│         Other globals               │  ← Corrupted by overflow
├─────────────────────────────────────┤
│         ...                         │
└─────────────────────────────────────┘
Higher addresses
```

---

## Why Java Is NOT Affected

### Java's Architecture Differences

| Aspect | zlib untgz (C) | Java java.util.zip |
|--------|----------------|-------------------|
| Memory model | Fixed C arrays | JVM heap objects |
| String handling | `strcpy()` | Java String class |
| Buffer allocation | Stack/global | Heap (dynamic) |
| Bounds checking | None | Automatic |
| Filename storage | `char fname[1024]` | `String` (unlimited) |

### Java's Zip Implementation

Java's `java.util.zip` package uses the native zlib library for compression algorithms (deflate/inflate) but:

1. **Does NOT include `contrib/` utilities**
   - Only core compression functions are used
   - `untgz` is a standalone utility, not part of core zlib

2. **Uses Java strings for filenames**
   ```java
   // Java code - no fixed buffer
   ZipEntry entry = new ZipEntry(veryLongFilename);
   // String is heap-allocated, can be any size
   ```

3. **Native code doesn't handle filenames**
   - Java passes compressed data to native zlib
   - Filename handling is done entirely in Java

### Code Path Analysis

```
Java Application
       │
       ▼
java.util.zip.ZipOutputStream
       │
       ▼
Java native methods (JNI)
       │
       ▼
zlib deflate() / inflate()  ← Only these are used
       │
       ▼
Compressed data

❌ TGZfname() is NEVER called
❌ fname[1024] is NEVER used
❌ strcpy() vulnerability is NOT reachable
```

---

## Java's Bundled zlib Analysis

### Location

```
OpenJDK source:
src/java.base/share/native/libzip/zlib/
```

### Files Included

| File | Purpose | Vulnerable? |
|------|---------|-------------|
| `deflate.c` | Compression | No |
| `inflate.c` | Decompression | No |
| `trees.c` | Huffman trees | No |
| `zutil.c` | Utilities | No |
| `crc32.c` | CRC calculation | No |
| `gzread.c` | gzip reading | No |
| `gzwrite.c` | gzip writing | No |

### Files NOT Included

| File | Purpose | Contains Vulnerability? |
|------|---------|------------------------|
| `contrib/untgz/untgz.c` | tar.gz extractor | **YES - CVE-2026-22184** |
| `contrib/minizip/*` | ZIP utilities | No |
| `contrib/puff/*` | Inflate demo | No |

---

## UBI10 System Analysis

### System zlib Package

UBI10 uses `zlib-ng-compat` instead of original zlib:

```
Package: zlib-ng-compat-2.2.3-2.el10.x86_64
Project: https://github.com/zlib-ng/zlib-ng
```

zlib-ng is a fork/rewrite of zlib with:
- Performance optimizations
- Different codebase
- No `contrib/` utilities included

### untgz Availability

```bash
$ which untgz
# Not found

$ dnf provides '*untgz*'
# No matches
```

The `untgz` utility does not exist in UBI10 at all.

---

## Test Results Summary

### Comprehensive Test (43 tests)

All Java compression APIs tested with filenames from 1025 to 65535 bytes:

| API | Tests | Result |
|-----|-------|--------|
| ZipOutputStream | 5 | ✅ PASS |
| ZipInputStream | 5 | ✅ PASS |
| GZIPOutputStream | 5 | ✅ PASS |
| GZIPInputStream | 5 | ✅ PASS |
| JarOutputStream | 5 | ✅ PASS |
| JarInputStream | 5 | ✅ PASS |
| Deflater/Inflater | 5 | ✅ PASS |
| ZipFile | 5 | ✅ PASS |
| Edge cases | 3 | ✅ PASS |
| **Total** | **43** | ✅ **ALL PASS** |

### C Vulnerability Demo

| Input Size | Result |
|------------|--------|
| 512 bytes | OK |
| 1024 bytes | OK |
| 1025 bytes | Overflow detected |
| 2000 bytes | **SIGSEGV (crash)** |
| 4096 bytes | **SIGSEGV (crash)** |

---

## Conclusion

CVE-2026-22184 **does NOT affect** Java 21 OpenJDK because:

1. ✅ The vulnerable `untgz` utility is not included
2. ✅ Java uses dynamic memory allocation
3. ✅ No fixed 1024-byte buffer exists in Java code
4. ✅ All 43 tests with oversized filenames passed
5. ✅ There is no code path to trigger the vulnerability

The C demo demonstrates the real vulnerability exists in zlib's untgz, but Java simply doesn't include this code.
