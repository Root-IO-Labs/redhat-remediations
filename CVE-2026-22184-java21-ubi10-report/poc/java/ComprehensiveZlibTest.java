import java.io.*;
import java.nio.file.*;
import java.util.zip.*;
import java.util.jar.*;
import java.util.*;

/**
 * CVE-2026-22184 Comprehensive Vulnerability Test
 * 
 * Tests ALL Java compression APIs to verify Java is NOT affected
 * by the zlib untgz buffer overflow vulnerability.
 * 
 * VULNERABILITY: zlib untgz uses a fixed 1024-byte buffer for filenames.
 *                strcpy() without bounds check causes overflow on long names.
 * 
 * EXPECTED RESULT: All tests should PASS because Java doesn't use untgz code.
 */
public class ComprehensiveZlibTest {
    
    private static final int VULNERABLE_BUFFER = 1024;
    private static final int[] OVERFLOW_SIZES = {1025, 2048, 4096, 8192, 16384};
    
    private static int testsRun = 0;
    private static int testsPassed = 0;
    private static int testsFailed = 0;
    
    public static void main(String[] args) throws Exception {
        printHeader();
        printJavaInfo();
        
        System.out.println("Testing ALL Java compression APIs that might use zlib...\n");
        
        for (int size : OVERFLOW_SIZES) {
            testZipOutputStream(size);
            testZipInputStream(size);
            testGZIPOutputStream(size);
            testGZIPInputStream(size);
            testJarOutputStream(size);
            testJarInputStream(size);
            testInflaterDeflater(size);
            testZipFile(size);
        }
        
        testExtremeFilename();
        testNestedArchives();
        testMalformedArchive();
        
        printSummary();
    }
    
    private static void printHeader() {
        System.out.println("╔═══════════════════════════════════════════════════════════════════════════════╗");
        System.out.println("║     CVE-2026-22184 Comprehensive Java Vulnerability Test                      ║");
        System.out.println("║     Testing ALL zlib-related APIs for buffer overflow                         ║");
        System.out.println("╚═══════════════════════════════════════════════════════════════════════════════╝");
        System.out.println();
    }
    
    private static void printJavaInfo() {
        System.out.println("Java Environment:");
        System.out.println("  Version:  " + System.getProperty("java.version"));
        System.out.println("  Vendor:   " + System.getProperty("java.vendor"));
        System.out.println("  Home:     " + System.getProperty("java.home"));
        System.out.println("  VM:       " + System.getProperty("java.vm.name"));
        System.out.println();
        System.out.println("Vulnerability Info:");
        System.out.println("  CVE:           CVE-2026-22184");
        System.out.println("  Component:     zlib untgz (contrib/untgz/untgz.c)");
        System.out.println("  Buffer size:   " + VULNERABLE_BUFFER + " bytes");
        System.out.println("  Attack:        Filename > " + VULNERABLE_BUFFER + " bytes causes overflow");
        System.out.println();
    }
    
    private static void testZipOutputStream(int filenameSize) {
        String testName = "ZipOutputStream with " + filenameSize + "-byte filename";
        testsRun++;
        
        try {
            String longName = "X".repeat(filenameSize - 4) + ".txt";
            String content = "Test content for " + filenameSize;
            
            Path zipFile = Files.createTempFile("test-", ".zip");
            
            try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
                ZipEntry entry = new ZipEntry(longName);
                zos.putNextEntry(entry);
                zos.write(content.getBytes());
                zos.closeEntry();
            }
            
            try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile.toFile()))) {
                ZipEntry entry = zis.getNextEntry();
                if (entry != null && entry.getName().equals(longName)) {
                    String read = new String(zis.readAllBytes());
                    if (read.equals(content)) {
                        pass(testName);
                        Files.deleteIfExists(zipFile);
                        return;
                    }
                }
            }
            
            fail(testName, "Content mismatch");
            Files.deleteIfExists(zipFile);
            
        } catch (Exception e) {
            fail(testName, e.getMessage());
        }
    }
    
    private static void testZipInputStream(int filenameSize) {
        String testName = "ZipInputStream with " + filenameSize + "-byte filename";
        testsRun++;
        
        try {
            String longName = "Y".repeat(filenameSize - 4) + ".dat";
            byte[] data = ("Data for " + filenameSize).getBytes();
            
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try (ZipOutputStream zos = new ZipOutputStream(baos)) {
                ZipEntry entry = new ZipEntry(longName);
                zos.putNextEntry(entry);
                zos.write(data);
                zos.closeEntry();
            }
            
            try (ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(baos.toByteArray()))) {
                ZipEntry entry = zis.getNextEntry();
                if (entry != null) {
                    byte[] read = zis.readAllBytes();
                    if (Arrays.equals(read, data)) {
                        pass(testName);
                        return;
                    }
                }
            }
            
            fail(testName, "Read failed");
            
        } catch (Exception e) {
            fail(testName, e.getMessage());
        }
    }
    
    private static void testZipFile(int filenameSize) {
        String testName = "ZipFile with " + filenameSize + "-byte filename";
        testsRun++;
        
        try {
            String longName = "Z".repeat(filenameSize - 4) + ".bin";
            byte[] data = new byte[1024];
            new Random().nextBytes(data);
            
            Path zipPath = Files.createTempFile("zipfile-", ".zip");
            
            try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipPath.toFile()))) {
                ZipEntry entry = new ZipEntry(longName);
                zos.putNextEntry(entry);
                zos.write(data);
                zos.closeEntry();
            }
            
            try (ZipFile zf = new ZipFile(zipPath.toFile())) {
                ZipEntry entry = zf.getEntry(longName);
                if (entry != null) {
                    try (InputStream is = zf.getInputStream(entry)) {
                        byte[] read = is.readAllBytes();
                        if (Arrays.equals(read, data)) {
                            pass(testName);
                            Files.deleteIfExists(zipPath);
                            return;
                        }
                    }
                }
            }
            
            fail(testName, "Entry not found");
            Files.deleteIfExists(zipPath);
            
        } catch (Exception e) {
            fail(testName, e.getMessage());
        }
    }
    
    private static void testGZIPOutputStream(int dataSize) {
        String testName = "GZIPOutputStream with " + dataSize + " bytes data";
        testsRun++;
        
        try {
            byte[] data = new byte[dataSize];
            for (int i = 0; i < dataSize; i++) {
                data[i] = (byte) (i % 256);
            }
            
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try (GZIPOutputStream gzos = new GZIPOutputStream(baos)) {
                gzos.write(data);
            }
            
            try (GZIPInputStream gzis = new GZIPInputStream(new ByteArrayInputStream(baos.toByteArray()))) {
                byte[] read = gzis.readAllBytes();
                if (Arrays.equals(read, data)) {
                    pass(testName);
                    return;
                }
            }
            
            fail(testName, "Data mismatch");
            
        } catch (Exception e) {
            fail(testName, e.getMessage());
        }
    }
    
    private static void testGZIPInputStream(int dataSize) {
        String testName = "GZIPInputStream decompress " + dataSize + " bytes";
        testsRun++;
        
        try {
            byte[] original = new byte[dataSize];
            Arrays.fill(original, (byte) 'A');
            
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try (GZIPOutputStream gzos = new GZIPOutputStream(baos)) {
                gzos.write(original);
            }
            
            try (GZIPInputStream gzis = new GZIPInputStream(new ByteArrayInputStream(baos.toByteArray()))) {
                ByteArrayOutputStream result = new ByteArrayOutputStream();
                byte[] buffer = new byte[VULNERABLE_BUFFER];
                int len;
                while ((len = gzis.read(buffer)) > 0) {
                    result.write(buffer, 0, len);
                }
                
                if (Arrays.equals(result.toByteArray(), original)) {
                    pass(testName);
                    return;
                }
            }
            
            fail(testName, "Decompression failed");
            
        } catch (Exception e) {
            fail(testName, e.getMessage());
        }
    }
    
    private static void testJarOutputStream(int filenameSize) {
        String testName = "JarOutputStream with " + filenameSize + "-byte entry";
        testsRun++;
        
        try {
            String longName = "J".repeat(filenameSize - 6) + ".class";
            byte[] classData = "CAFEBABE".getBytes();
            
            Path jarPath = Files.createTempFile("test-", ".jar");
            
            Manifest manifest = new Manifest();
            manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
            
            try (JarOutputStream jos = new JarOutputStream(new FileOutputStream(jarPath.toFile()), manifest)) {
                JarEntry entry = new JarEntry(longName);
                jos.putNextEntry(entry);
                jos.write(classData);
                jos.closeEntry();
            }
            
            try (JarInputStream jis = new JarInputStream(new FileInputStream(jarPath.toFile()))) {
                JarEntry entry;
                while ((entry = jis.getNextJarEntry()) != null) {
                    if (entry.getName().equals(longName)) {
                        byte[] read = jis.readAllBytes();
                        if (Arrays.equals(read, classData)) {
                            pass(testName);
                            Files.deleteIfExists(jarPath);
                            return;
                        }
                    }
                }
            }
            
            fail(testName, "Entry not found in JAR");
            Files.deleteIfExists(jarPath);
            
        } catch (Exception e) {
            fail(testName, e.getMessage());
        }
    }
    
    private static void testJarInputStream(int filenameSize) {
        String testName = "JarInputStream with " + filenameSize + "-byte entry";
        testsRun++;
        
        try {
            String longName = "K".repeat(filenameSize - 5) + ".java";
            String code = "public class Test { }";
            
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            Manifest m = new Manifest();
            m.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
            
            try (JarOutputStream jos = new JarOutputStream(baos, m)) {
                jos.putNextEntry(new JarEntry(longName));
                jos.write(code.getBytes());
                jos.closeEntry();
            }
            
            try (JarInputStream jis = new JarInputStream(new ByteArrayInputStream(baos.toByteArray()))) {
                JarEntry entry = jis.getNextJarEntry();
                if (entry != null && entry.getName().equals(longName)) {
                    String read = new String(jis.readAllBytes());
                    if (read.equals(code)) {
                        pass(testName);
                        return;
                    }
                }
            }
            
            fail(testName, "Content verification failed");
            
        } catch (Exception e) {
            fail(testName, e.getMessage());
        }
    }
    
    private static void testInflaterDeflater(int dataSize) {
        String testName = "Deflater/Inflater with " + dataSize + " bytes";
        testsRun++;
        
        try {
            byte[] original = new byte[dataSize];
            for (int i = 0; i < dataSize; i++) {
                original[i] = (byte) (i % 128);
            }
            
            Deflater deflater = new Deflater();
            deflater.setInput(original);
            deflater.finish();
            
            byte[] compressed = new byte[dataSize * 2];
            int compressedLen = deflater.deflate(compressed);
            deflater.end();
            
            Inflater inflater = new Inflater();
            inflater.setInput(compressed, 0, compressedLen);
            
            byte[] decompressed = new byte[dataSize];
            int decompressedLen = inflater.inflate(decompressed);
            inflater.end();
            
            if (decompressedLen == dataSize && Arrays.equals(original, decompressed)) {
                pass(testName);
            } else {
                fail(testName, "Data mismatch after inflate");
            }
            
        } catch (Exception e) {
            fail(testName, e.getMessage());
        }
    }
    
    private static void testExtremeFilename() {
        String testName = "Extreme filename (65535 bytes - ZIP limit)";
        testsRun++;
        
        try {
            int extremeSize = 65535;
            String extremeName = "E".repeat(extremeSize - 4) + ".txt";
            
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            try (ZipOutputStream zos = new ZipOutputStream(baos)) {
                ZipEntry entry = new ZipEntry(extremeName);
                zos.putNextEntry(entry);
                zos.write("test".getBytes());
                zos.closeEntry();
            }
            
            try (ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(baos.toByteArray()))) {
                ZipEntry entry = zis.getNextEntry();
                if (entry != null && entry.getName().length() == extremeName.length()) {
                    pass(testName);
                    return;
                }
            }
            
            fail(testName, "Extreme filename not preserved");
            
        } catch (Exception e) {
            System.out.println("  [SKIP] " + testName + " - " + e.getMessage());
            testsRun--;
        }
    }
    
    private static void testNestedArchives() {
        String testName = "Nested ZIP archives with long names";
        testsRun++;
        
        try {
            String longName = "N".repeat(2000) + ".zip";
            
            ByteArrayOutputStream innerBaos = new ByteArrayOutputStream();
            try (ZipOutputStream innerZos = new ZipOutputStream(innerBaos)) {
                innerZos.putNextEntry(new ZipEntry("inner.txt"));
                innerZos.write("inner content".getBytes());
                innerZos.closeEntry();
            }
            
            ByteArrayOutputStream outerBaos = new ByteArrayOutputStream();
            try (ZipOutputStream outerZos = new ZipOutputStream(outerBaos)) {
                outerZos.putNextEntry(new ZipEntry(longName));
                outerZos.write(innerBaos.toByteArray());
                outerZos.closeEntry();
            }
            
            try (ZipInputStream outerZis = new ZipInputStream(new ByteArrayInputStream(outerBaos.toByteArray()))) {
                ZipEntry outerEntry = outerZis.getNextEntry();
                if (outerEntry != null) {
                    byte[] innerZipData = outerZis.readAllBytes();
                    
                    try (ZipInputStream innerZis = new ZipInputStream(new ByteArrayInputStream(innerZipData))) {
                        ZipEntry innerEntry = innerZis.getNextEntry();
                        if (innerEntry != null) {
                            String content = new String(innerZis.readAllBytes());
                            if (content.equals("inner content")) {
                                pass(testName);
                                return;
                            }
                        }
                    }
                }
            }
            
            fail(testName, "Nested extraction failed");
            
        } catch (Exception e) {
            fail(testName, e.getMessage());
        }
    }
    
    private static void testMalformedArchive() {
        String testName = "Malformed archive handling";
        testsRun++;
        
        try {
            byte[] garbage = new byte[2048];
            garbage[0] = 'P';
            garbage[1] = 'K';
            garbage[2] = 0x03;
            garbage[3] = 0x04;
            for (int i = 4; i < garbage.length; i++) {
                garbage[i] = (byte) (i % 256);
            }
            
            try (ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(garbage))) {
                try {
                    ZipEntry entry = zis.getNextEntry();
                } catch (ZipException e) {
                    pass(testName + " (ZipException caught as expected)");
                    return;
                }
            }
            
            pass(testName + " (no crash)");
            
        } catch (ZipException e) {
            pass(testName + " (ZipException at stream level)");
        } catch (Exception e) {
            pass(testName + " (" + e.getClass().getSimpleName() + ")");
        }
    }
    
    private static void pass(String testName) {
        testsPassed++;
        System.out.println("  ✅ PASS: " + testName);
    }
    
    private static void fail(String testName, String reason) {
        testsFailed++;
        System.out.println("  ❌ FAIL: " + testName + " - " + reason);
    }
    
    private static void printSummary() {
        System.out.println();
        System.out.println("╔═══════════════════════════════════════════════════════════════════════════════╗");
        System.out.println("║                              TEST SUMMARY                                     ║");
        System.out.println("╚═══════════════════════════════════════════════════════════════════════════════╝");
        System.out.println();
        System.out.println("  Total tests:  " + testsRun);
        System.out.println("  Passed:       " + testsPassed);
        System.out.println("  Failed:       " + testsFailed);
        System.out.println();
        
        if (testsFailed == 0) {
            System.out.println("  ═══════════════════════════════════════════════════════════════════════════");
            System.out.println("  ✅ ALL TESTS PASSED - Java is NOT affected by CVE-2026-22184");
            System.out.println("  ═══════════════════════════════════════════════════════════════════════════");
            System.out.println();
            System.out.println("  CONCLUSION:");
            System.out.println("  • All Java compression APIs handled long filenames safely");
            System.out.println("  • No buffer overflow was triggered");
            System.out.println("  • Java's zlib usage does NOT include the vulnerable untgz code");
            System.out.println("  • CVE-2026-22184 does NOT affect Java applications");
            System.out.println();
            System.exit(0);
        } else {
            System.out.println("  ⚠️ SOME TESTS FAILED - Review output above");
            System.out.println();
            System.exit(1);
        }
    }
}
